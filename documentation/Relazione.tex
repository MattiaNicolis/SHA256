\documentclass[12pt, a4paper, oneside]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[a4paper, margin=2.5cm]{geometry}

\usepackage{xcolor}
\definecolor{azzurrino}{HTML}{8B795E}
\definecolor{grigiochiaro}{HTML}{F5F5F5}
\definecolor{grigioscuro}{HTML}{424242}

\usepackage[
    colorlinks=true,
    linkcolor=grigioscuro,
    citecolor=azzurrino,
    urlcolor=azzurrino
]{hyperref}

\usepackage{titlesec}

\titleformat{\chapter}[display]
  {\normalfont\Huge\bfseries\color{azzurrino}}
  {\filleft\Huge\thechapter}
  {0pt}
  {\titlerule[1pt]\vspace{1ex}\filright}
  [\vspace{1ex}\titlerule]

\titleformat{\section}
  {\normalfont\Large\bfseries\color{azzurrino}}{\thesection}{1em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries\color{grigioscuro}}{\thesubsection}{1em}{}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\titleformat{\subsubsection}
  {\normalfont\large\bfseries\color{grigioscuro}}{\thesubsubsection}{1em}{}

\usepackage[font=small, labelfont={bf, color=azzurrino}]{caption}

\usepackage{fancyhdr}
\setlength{\headheight}{25pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\color{grigioscuro}\leftmark}
\fancyhead[R]{\color{azzurrino}\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{azzurrino}\leaders\hrule height \headrulewidth\hfill}}

\usepackage{enumitem}
\setlist{nosep, leftmargin=1.5em}

\usepackage{graphicx}
\usepackage{bookmark}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{subcaption}
\usepackage{soul}
\usepackage{parskip}
\usepackage{mdframed}

\usepackage[most]{tcolorbox}
\tcbuselibrary{listings, skins, breakable, theorems}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{longtable}
\usepackage{array}
\usepackage{tabularx}

\title{\Huge\bfseries \textcolor{azzurrino}{SHA-256} \\[0.5ex]
\textcolor{azzurrino}{Opzione 2: Phtread \& FIFO} \\[1ex]
\Large UniVR - Dipartimento di Informatica \\[1.5ex]
\Large A.A. 2025/26}
\author{
\Large{Mattia Nicolis -- VR500356}
}
\date{}

% =================================
\begin{document}
    \frontmatter
    \maketitle
    \tableofcontents
    \thispagestyle{empty}
    \newpage

    %===========================
    \mainmatter

    % --- CAPITOLO 1 - BREVE SPIEGAZIONE DEL PROGETTO ---
    \chapter{Introduzione}
    Il progetto consiste nella realizzazione di un sistema client-server per il calcolo concorrente dell'hash SHA-256.\\[0.2ex]
    L'obiettivo principale è massimizzare il throughput tramite un'architettura multithread, garantendo al contempo l'uso efficiente delle risorse e la robustezza del sistema.

    % --- CAPITOLO 2 - BREVE SPIEGAZIONE DELLA STRUTTURA DEL PROGETTO ---
    \chapter{Architettura e specifiche implementate}
    Il sistema è strutturato secondo un modello Master-Worker, dove un processo Server centrale gestisce le richieste provenienti da molteplici Client.

    \section{Componenti principali}
    \begin{itemize}
      \item \textbf{main thread (dispatcher)}: è il cuore del server.
      
      Si occupa esclusivamente di ascoltare la FIFO pubblica, deserializzare le richieste in arrivo e inserirle nella coda condivisa (\verb|request_queue|).

      \medskip
      \item \textbf{worker threads}: thread pre-allocati (thread pool) che prelevano le richieste dalla coda. 
      
      Ciascun worker è responsabile della verifica in cache, dell'eventuale calcolo CPU-intensive (SHA-256), dell'aggiornamento della cache e dell'invio della risposta sulla FIFO privata del client.
    \end{itemize}
    
    \section{Specifiche implementate}
    Le specifiche principali implementate includono:
    \begin{itemize}[label=$\triangleright$]
      \item \textbf{comunicazione inter-processo (IPC)}: utilizzo di una FIFO pubblica (\texttt{/tmp/sha256\_server\_fifo}) per le richieste e FIFO private univoche per le risposte, prevenendo deadlock comunicativi
      \medskip
      \item \textbf{gestione della concorrenza (thread pool)}: un main thread agisce da dispatcher, mentre un pool dinamico di worker threads (massimo 3) esegue i calcoli CPU-intensive
      \medskip
      \item \textbf{scheduling shortest job first (SJF)}: implementazione di una coda prioritaria che ordina le richieste in base alla dimensione del file, minimizzando il tempo di attesa medio
      \medskip
      \item \textbf{caching ($\boldsymbol{\text{O(1)}}$)}: memorizzazione dei risultati calcolati per evitare ricalcoli inutili su file già processati
    \end{itemize}

    %foto

    \chapter{Scelte implementative e dettagli tecnici}
    In questa sezione si analizzano le soluzioni adottate per soddisfare i requisiti.

    \section{Gestione della concorrenza}
    Per garantire la sicurezza dei dati (thread safety) evitando complessità eccessive e rischi di deadlock, si è scelto di utilizzare un approccio basato su un mutex globale (\verb|server_mutex|):
    \begin{itemize}
      \item \textbf{funzionamento}: questo singolo mutex protegge l'accesso a tutte le risorse condivise critiche: la coda delle richieste (\verb|request_queue|) e la cache dei risultati (\verb|hash_cache|)
      \smallskip
      \item \textbf{motivazione}: sebbene teoricamente meno performante di lock granulari, questa scelta semplifica drasticamente la logica di sincronizzazione, garantendo che non si verifichino mai interblocchi tra thread che tentano di accedere a risorse diverse simultaneamente
    \end{itemize}

    \section{Scheduling e priorità (SJF)}
    Il cuore dell'ottimizzazione risiede nello scheduler. Invece di una classica coda FIFO (First-In First-Out), le richieste vengono inserite nella lista in modo ordinato in base alla dimensione del file (\verb|file_size|):
    \begin{itemize}
      \item \textbf{implementazione}: la funzione \verb|enqueue_request| scansiona la lista e inserisce il nuovo nodo nella posizione corretta
      \smallskip
      \item \textbf{vantaggio}: questo implementa la politica Shortest Job First (SJF), assicurando che i file piccoli non rimangano bloccati dietro a file di grandi dimensioni, migliorando il tempo di risposta medio del sistema
    \end{itemize}

    \section{Caching dei risultati}
    Per ridurre il carico sulla CPU, è stata implementata una cache in memoria (Linked List):
    \begin{itemize}
      \item \textbf{funzionamento}: Prima di avviare il calcolo SHA-256, ogni worker thread controlla se il percorso del file è già presente nella lista \verb|hash_cache|
      \smallskip
      \item \textbf{cache hit}: se il file è stato già elaborato in precedenza, il risultato viene restituito immediatamente, riducendo il tempo di servizio da $\text{O(N)}$ (dove N è la dimensione del file) a $\text{O(1)}$ (costante)
    \end{itemize}

    \chapter{Difficoltà riscontrate}
    Durante lo sviluppo sono emerse sfide critiche legate alla natura concorrente del progetto.

    \section{Sincronizzazione delle FIFO}
    Inizialmente, il server completava il calcolo ma il client rimaneva bloccato in attesa indefinita.\\[0.2ex]
    Il problema risiedeva nella gestione delle \verb|open()| bloccanti.\\[0.2ex]
    È stato necessario sincronizzare l'apertura in lettura del client con l'apertura in scrittura del Server, garantendo che il canale fosse pronto prima dell'invio dei dati.

    \section{Gestione dei puntatori nella coda prioritaria}
    L'inserimento ordinato (SJF) in una lista linkata condivisa causava race conditions e corruzione della memoria.\\[0.2ex]
    L'implementazione ha richiesto una protezione rigorosa tramite mutex durante la scansione lineare ($\text{O(N)}$) per l'inserimento in testa o nel mezzo della lista.

    \section{Deadlock logici in caso di errori}
    Se un file non esisteva, il thread terminava senza rimuovere il file dalla lista "pending", bloccando per sempre eventuali richieste future per lo stesso nome file.\\[0.2ex]
    È stata introdotta una routine di pulizia (\verb|remove_from_pending|) che viene invocata tassativamente anche nei rami di errore (es. file non trovato)


    \chapter{Test e risultati}
    Il sistema è stato collaudato verificando i casi d'uso principali e la gestione degli errori.
    
    \section{Verifica scheduling SJF}
    Lanciando in sequenza un file di grandi dimensioni (es. 100MB) seguito immediatamente da un file piccolo (es. 1MB), è stato verificato dai log del server che il file da 1MB viene processato e completato prima di quello più grande, confermando che la coda viene riordinata correttamente in base alla dimensione (\verb|file_size|).

    \section{Verifica del caching}
    Per verificare l'efficacia del caching, è stato effettuato un test sequenziale:
    \begin{enumerate}
      \item \textbf{prima richiesta}: il server calcola l'hash (tempo: proporzionale alla dimensione)
      \smallskip
      \item \textbf{seconda richiesta (stesso file)}: il server rileva il file nella lista \verb|hash_cache| e restituisce il risultato istantaneamente (tempo costante $\text{O(1)}$), senza rileggere il file da disco
    \end{enumerate}

    \section{Test di robustezza}
    È stato simulato l'invio di una richiesta per un file non presente sul server:
    \begin{itemize}
      \item \textbf{comando}: \verb|./client file_fantasma.txt|
      \item \textbf{risultato}: il server utilizza la funzione access() per verificare l'esistenza del file prima di tentare l'apertura. 
      
      Invece di terminare in modo anomalo (crash), invia correttamente al client una stringa contenente l'errore (\verb|"ERRORE_FILE_NOT_FOUND"|), garantendo la stabilità del servizio
    \end{itemize}

    \chapter{Guida alla compilazione e avvio}

    \section{Prerequisiti}
    Il sistema richiede la presenza delle librerie OpenSSL per il calcolo dell'hash e del tool CMake per la gestione della compilazione:
    \begin{itemize}
      \item sistemi Debian/Ubuntu: sudo apt install libssl-dev cmake
      \smallskip
      \item sistemi macOS: brew install openssl cmake
    \end{itemize}

    \section{Compilazione}
    Per garantire una compilazione pulita, è stato utilizzato CMake.
    
    Seguire i seguenti passaggi dalla root del progetto:
    \begin{tcolorbox}[
        title=Bash,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|mkdir build|
      
      \verb|cd build|
      
      \verb|cmake ..|
      
      \verb|make|
    \end{tcolorbox}

    Al termine dell'operazione, verranno generati tre eseguibili nella cartella \verb|build/|: \verb|server|, \verb|client| e \verb|cache_query|.

    \section{Esecuzione}
    Per un corretto funzionamento, i componenti devono essere avviati in terminali separati seguendo quest'ordine:
    Seguire i seguenti passaggi dalla root del progetto:
    \begin{tcolorbox}[
        title=Bash,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./server|
    \end{tcolorbox}

    Il server inizializzerà la FIFO pubblica e si metterà in ascolto.

    In un secondo terminale, lanciare il client indicando un file esistente:
    \begin{tcolorbox}[
        title=Bash,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./client| \verb|percorso/nome_file.txt|
    \end{tcolorbox}

    Per verificare lo stato della memoria interna del server:
    \begin{tcolorbox}[
        title=Bash,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./cache_query|
    \end{tcolorbox}
\end{document}